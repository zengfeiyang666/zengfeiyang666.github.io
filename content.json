{"pages":[{"title":"About me","text":"","link":"/about/me.html"},{"title":"","text":"[{\"img\":\"/json-data/banner/lonelyreader.png\",\"url\":\"https://lonelyreader.com\",\"alt\":\"孤独的阅读者\"},{\"img\":\"/json-data/banner/blog-build.png\",\"url\":\"https://space.bilibili.com/386767453/channel/detail?cid=89247\",\"alt\":\"博客搭建视频教程\"},{\"img\":\"/json-data/banner/git-github.jpg\",\"url\":\"https://space.bilibili.com/386767453/channel/detail?cid=84534\",\"alt\":\"让你彻底理解Git视频教程\"}]","link":"/json-data/main-banner.json"},{"title":"美好瞬间","text":"","link":"/photo/index.html"},{"title":"Java8学习","text":"资源路径Lambda表达式 关于Java Lambda表达式看这一篇就够了https://objcoding.com/2019/03/04/lambda/ java8 函数式接口简介 https://blog.csdn.net/qq_28410283/article/details/80962325 泛型摘录拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。 这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了参数化类型，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。 一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。 因此，与其使用 Object ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，T 就是类型参数： 1234567891011121314public class GenericHolder&lt;T&gt; { private T a; public GenericHolder() {} public void set(T a) { this.a = a; } public T get() { return a; } public static void main(String[] args) { GenericHolder&lt;Automobile&gt; h3 = new GenericHolder&lt;Automobile&gt;(); h3.set(new Automobile()); // 此处有类型校验 Automobile a = h3.get(); // 无需类型转换 //- h3.set(\"Not an Automobile\"); // 报错 //- h3.set(1); // 报错 }} 创建 GenericHolder 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 main() 中那样使用。然后，你就只能在 GenericHolder 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 get() 取值时，直接就是正确的类型。 这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。","link":"/temp/Java8%E5%AD%A6%E4%B9%A0.html"},{"title":"","text":"状态码目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。但如果把代码简单地从 000 开始顺序编下去就显得有点太“low”，不灵活、不利于扩展，所以状态码也被设计成有一定的格式。 RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 099 不用，这样状态码的实际可用范围就大大缩小了，由 000999 变成了 100~599。 这五类的具体含义是： 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作； 2××：成功，报文已经收到并被正确处理； 3××：重定向，资源位置发生变动，需要客户端重新发送请求； 4××：客户端错误，请求报文有误，服务器无法处理； 5××：服务器错误，服务器在处理请求时内部发生了错误。 3××3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。 “301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。 与它类似的是“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。 301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。 比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。 再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。","link":"/temp/HTTP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3.html"},{"title":"","text":"技术框架MyBatis-PlusMyBatis-Plus 官网 https://mp.baomidou.com MyBatis-Plus 视频教程 MyBatis-Plus入门 https://www.imooc.com/learn/1130 MyBatis-Plus进阶 https://www.imooc.com/learn/1171 mybatismybatis文档 https://mybatis.org/mybatis-3/zh/index.html# mybatis 3.5 源码解析 MyBatis源码阅读网","link":"/temp/Java%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD%E7%82%B9%E8%AE%B0%E5%BD%95.html"},{"title":"","text":"Linux操作命令1：使用rm -rf 目录名字 命令即可 ​ -r 就是向下递归，不管有多少级目录，一并删除​ -f 就是直接强行删除，不作任何提示的意思 rm 不带参数 只能删除文件​ 例如：rm test.txt，删除文件test.txt","link":"/temp/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.html"},{"title":"","text":"临时记录“爬虫”（Crawler） TCP/IP分层设计思想TCP/IP 当初的设计者真的是非常聪明，创造性地提出了“分层”的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，层次内只专心做自己的事情就好，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。 域名的形式在第 4 讲曾经说过，域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。 最左边的是主机名，通常用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务，不过这也不是绝对的，名字的关键是要让我们容易记忆。 看一下极客时间的域名“time.geekbang.org”，这里的“org”就是顶级域名，“geekbang”是二级域名，“time”则是主机名。使用这个域名，DNS 就会把它转换成相应的 IP 地址，你就可以访问极客时间的网站了。 域名的解析就像 IP 地址必须转换成 MAC 地址才能访问主机一样， 域名也必须要转换成 IP 地址，这个过程就是“域名解析”。 架构相关汇编语言的出现要早于操作系统。操作系统的核心目标是软件治理，只有在计算机需要管理很多的任务时，才需要有操作系统。 计算机加电启动后，中央处理器（CPU）会从一个固定的存储地址加载指令序列执行。通常，这个固定的存储地址指向计算机主板的 ROM 上的一段启动程序（BIOS）。 内存是进程运行的基础资源，保持进程基础资源的独立性，是软件治理的最基础的要求。 操作系统则属于基础软件，它和我们编写的软件并不在同一个进程（进程是软件的一个运行后产生的实例，同一个软件可以运行多次得到多个进程）中。 线程的出现，则是因为操作系统发现同一个软件内还是会有多任务的需求，这些任务处在相同的地址空间，彼此之间相互可以信任。 数字化https://mp.weixin.qq.com/s/FTWB9jc0qHnX9e38VtU4aw 现实世界由万事万物构成，而计算机能够处理，只有数据。说得更直接一点，计算机能够处理的其实都是数字。因此，当我们用计算机来协助处理日常事物的时候，首先要做的一件事就是数字化。 虽然在实践中，通常存储在计算机存储设备上的数字化数据是二进制形式的。但严格来说，任何把模拟源转换为任意类型数字格式的过程，都可以叫做数字化。 数字化指将信息转换成数字格式的过程。具体而言，就是把一个物体，图像，声音，文本或者信号转换为一系列数字的集合： 一张图片的数字化是将其被分割成若干的像素，每个像素用 R（red，红色）G（green，绿色）B（blue，蓝色）三种颜色分量对应的三个 0-255 的值来表示； 一段声音的数字化则是将记录下来的模拟声波经由傅里叶变换转化为若干三角函数的叠加； 文字的数字化是针对不同字符体系进行编码，将某一字符转化为一个特定的数字“号码”； ……","link":"/temp/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95.html"},{"title":"","text":"SPASPA（single page web application），单页面应用，是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。在单页应用中，所有必要的代码（ HTML、JavaScript 和 CSS ）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面。SPA 有一个缺点，因为 SPA 应用部署后只有1个页面，而且这个页面只是一堆 js 、css 引用，没有其他有效价值，因此，SPA 应用不易被搜索引擎收录，所以，一般来说，SPA 适合做大型企业后台管理系统。 Vue 使用方式大致上可以分为两大类： 直接将Vue在页面中引入，不做 SPA 应用 SPA应用","link":"/temp/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-%E6%A6%82%E8%A7%88.html"},{"title":"","text":"技术精彩文章锦集搜课程https://www.kcsou.com/s_Java/ 阿里巴巴Java开发手册https://www.php.cn/course/346.html SpringCloud相关 拜托！面试请不要再问我Spring Cloud底层原理! https://www.jianshu.com/p/c68b9b79aee9 【性能优化之道】每秒上万并发下的Spring Cloud参数优化实战 https://www.jianshu.com/p/9d9a648c2df8 Spring相关 徒手撸框架–实现IoC 徒手撸框架–实现Aop MySQL相关 MySQL的万字总结（缓存，索引，Explain，事务，redo日志等） https://www.jianshu.com/p/2530d1185778 安全相关1：写一篇最好懂的HTTPS讲解 2：读“一篇最好懂的https讲解”有感 压力测试JMeter从入门到精通 视频 https://www.bilibili.com/video/BV1SQ4y1M7s1?p=4 Jmeter插件下载地址：https://jmeter-plugins.org/install/Install/ 测试教程网 http://www.testclass.net 1：Mac 安装 JMeter，JMeter 下载，JMeter Http 压力测试【图解】 2：使用JMeter完成压力测试入门 3：Jmeter并发数 测试 4：Jmeter安装与脚本录制（Mac） IO操作相关 服务化基石之远程通信系列三：I/O模型 Kafka相关Kafka概念理解 kafka 上手指南：单节点 Mac安装KafkaRedis相关 Redis缓存雪崩和穿透的解决方法 SEO相关SEO新人必看！SEO是什么？SEO怎么做","link":"/temp/%E6%8A%80%E6%9C%AF%E7%B2%BE%E5%BD%A9%E6%96%87%E7%AB%A0%E9%94%A6%E9%9B%86.html"},{"title":"","text":"前端资源收藏1：轮播图插件swiper [https://www.swiper.com.cn]","link":"/temp/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F.html"},{"title":"技术视频学习","text":"Redis相关 最新Redis教程，入门到实战（付源码、笔记） 2020年最全Redis高并发项目场景设计实战全集（淘宝购物车，微信点赞，微博关系设计等） 源码相关 源码阅读网 责任链设计模式","link":"/temp/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0.html"},{"title":"精彩博文收集","text":"关于学习方法 Coursera人气课程：学会如何学习 （一） 方法看大牛是如何阅读JDK源码，涨涨见识 如何阅读源码？ 给学妹的 Java 学习路线 如何阅读Java源码，阅读Java的真实体会 为什么我们要阅读源码？","link":"/temp/%E7%B2%BE%E5%BD%A9%E5%8D%9A%E6%96%87%E6%94%B6%E9%9B%86.html"}],"posts":[{"title":"Hexo博客中图片显示问题","text":"1. 发现问题在HEXO发布的博文中，查看网页中的文章时，发现文章中的图片均不能查看，只是显示了图片的标题问题，查看控制台中的请求的数据发现，文章页面中的图片资源均是加载失败，对于在HEXO博客中的问题图片问题进行分析解决； 2. 解决问题方法 把HEXO配置文件 _config.yml中的post_asset_folder属性以及 permalink 属性， 1234# 是否启动资源文件夹，开启后通过 hexo new title ,(title为文章标题)生成新文章会建立一个同名的文件夹post_asset_folder: true# 生成文章链接的格式，这是默认的格式；修改的规则也比较简单，标签前面要加英文冒号；（注意图片资源生成的格式必须是这个格式，否则会出现图片加载失败的情况）permalink: :year/:month/:day/:title/ ​ 2.安装一个可以上传本地图片的插件，在HEXO项目的根目录下输入 1sudo npm install https://github.com/CodeFalling/hexo-asset-image --save ​ 3.再运行 hexo new post title 来生成 _posts 目录的MD文档时，在 /source/_posts 文件夹内会 建立一个与title文件同名的文件夹，结构如下 1234文章名称├── bird.jpg└── mouse.jpg文章名称.md ​ 4.在title.md文档中想引入图片时，先把图片复制到title.md这个文件夹中，然后只需要在文档中按照 markdown 的格式引入图片即可，如下： 1![图片标题](title/name.jpg) ​ 5.执行hexo打包命令hexo g，可以在本地项目根目录下的public文件夹查看生成的文件形式，再执行上传 命令hexo d后，就能在网页上查看到文字的图片资源了； ​ 6.打开博客文章的网页控制台，可以查看到图片资源引入的格式为： 1&lt;img src=\"/2020/03/27/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/%E5%8F%91%E5%B8%83%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"\"&gt; 最后完成了博客文章的图片资源的显示，如下图所示：","link":"/2020/03/27/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"},{"title":"Hexo搭建博客，注册域名，部署到GitHub","text":"1、Hexo搭建博客步骤暂时略过 2、注册域名 在腾讯云购买域名flymoon1028.com. 进行实名认证，域名备案（我申报后大概3小时就通过了，这个根据情况而定）。 备案通过后进行域名解析1）打开iTerm,输入ping命令，得到github上博客IP地址 1ping zengfeiyang666.github.io 得到GitHub博客的IP地址185.199.109.153 2）登录腾讯云平台，进行域名解析 4.GitHub和域名绑定 ​ 1）登录github博客项目，在博客根目录下创建文件名为：CNAME的文件，内容为域名： ​ www.flymoon1028.com ​ 3、通过绑定好的域名访问博客","link":"/2020/03/27/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%B3%A8%E5%86%8C%E5%9F%9F%E5%90%8D%EF%BC%8C%E9%83%A8%E7%BD%B2%E5%88%B0GitHub/"},{"title":"Mac中执行svn命令失效","text":"今天到公司，打开IDEA准备从SVN更新代码，显示无法连接SVN。What?搞什么鬼！ 打开iTerm,输入svn –version，想看一下svn版本号，确认一下svn是否真不可用了，果不其然，效果如图： 看到这个报错，以为没有安装Xcode,晚上搜索了下，执行xcode-select –install命令，提示如图： 可见，xcode没问题，接下来又是一顿各种搜索，什么重装xcode、重装comman line，貌似都不起作用。 经过一上午折腾，最终根据一篇博文提示，要不用brew重装一下svn，试下再说吧。 安装一切顺利，接下来再执行一下svn –version命令 svn命令正常了！ 又可以在IDEA中用svn愉快地提交代码了！ （PS：至于问题为什么这样解决，仍不是很明了，先记录一下）","link":"/2020/03/27/Mac%E4%B8%AD%E6%89%A7%E8%A1%8Csvn%E5%91%BD%E4%BB%A4%E5%A4%B1%E6%95%88/"},{"title":"window.open打开新窗口被浏览器拦截的处理方法","text":"​ 中台项目快上线了，昨天测试同学突然测出门户端菜单跳转点击没反应，在这之前测了那么久都没问题的，怎么就突然跳转不了了，奇了怪了。 ​ 到测试同学机器上一看，通过F12调试页面并没有查出问题，但发现地址栏右上角有个红色的X号，点开一看，跳转竟然被浏览器拦截了。同样是Chrome浏览器，我机器上好好的，测试同学进入跳转不了。于是网上一顿搜索，发现竟然是浏览器出于安全考虑，屏蔽了非用户操作的window.open()操作。参考如下几篇博文描述： window.open打开新窗口被浏览器拦截的处理方法 window.open()被部分浏览器拦截问题 详解window.open被浏览器拦截的解决方案 参考了以上几篇博文的方法调整，部分方法也能解决问题，但是我们的业务是在跳转之前，先调ajax方法判断是否有调整权限，有权限才跳转，没权限就提示。 起初先用如下方法实现，但考虑多如果用户没权限就事先给开个窗体，没权限再关闭，用户体验不好 1234567// 打开页面，此处最好使用提示页面var newWin = window.open('_blank');ajax().done(function() { // 重定向到目标页面 newWin.location.href = 'target url';}); 就放弃了该实现形式。 后面才用了leader得方案，定义一个变量保存初始值，写个定时器刷新等待异步ajax执行结果，将页面跳转的判断还放在用户的click事件中，这样浏览器就不好拦截了，毕竟是click是用户行为。实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253enterLapp(menuId, portalUrl, name, type) { //能否打开链接，初始化值为-1 var isOpen = -1; var openUrl = ''; //判断用户是否有该菜单权限 let listQuery = { menuId: menuId }; checkShortcutValidity(listQuery) .then(res =&gt; { if (res.data &amp;&amp; res.data.errCode === 200) { if (res.data.data) { if (type == \"HTTP\") { isOpen = 1; openUrl = portalUrl; //console.log(\"跳转：isOpen=\" + isOpen + \";openUrl=\" + openUrl); } else { let routeUrl = this.$router.resolve({ path: \"/LinkPage\", query: { portalUrl } }); isOpen = 1; openUrl = routeUrl.href; //console.log(\"跳转：isOpen=\" + isOpen + \";openUrl=\" + openUrl); } } else { isOpen = 0; MessageBox.alert(\"您没有该轻应用的访问权限，请联系企业管理员设置！\",'',{confirmButtonText:'确定',type:'info'}) .then(() =&gt; {}) } } else { isOpen = 0; MessageBox.alert(\"您没有该轻应用的访问权限，请联系企业管理员设置！\",'', {confirmButtonText:'确定',type:'info'}) .then(() =&gt; {}) } }) .catch(error =&gt; {}); //开启定时器 var interval = setInterval(function(){ //console.log(\"定时器开启......\") if(isOpen === 1 || isOpen === 0){ clearInterval(interval); if(isOpen == 1){ //console.log(\"跳转：name=\" + name + \";openUrl=\" + openUrl); window.open(openUrl, name); } } }, 600);}","link":"/2020/04/10/window-open%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%A6%E6%88%AA%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"},{"title":"浏览器缓存之Jquery自动给所有Ajax请求加上时间戳","text":"在使用 jQuery 请求数据时，我们可能希望它能自动附带上一些额外的参数。比如： 让所有请求自动加上时间戳，这样每次请求就不会有缓存。 或者让所有请求自动带上权限认证的 token，这样不用再为每个请求单独添加这个参数。 下面通过样例演示这个功能如何实现。 1，样例代码（1）这里我们使用 jQuery 的 ajaxSetup() 方法来进行全局配置，该方法可以为将来所有的 AJAX 请求设置默认值。（2）通过 ajaxSetup() 方法中的 beforeSend 属性可以设置发送请求前运行的函数（它会拦截所有的请求)，我们在此对 url 进行修改，增加个时间戳参数。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-3.1.1.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //全局配置 $.ajaxSetup({ beforeSend: function(jqXHR, settings) { //在请求前给修改url（增加一个时间戳参数） settings.url += settings.url.match(/\\?/) ? &quot;&amp;&quot; : &quot;?&quot;; settings.url += &quot;token=&quot; + new Date().getTime(); }, }); //按钮点击响应 function btnClick() { $.get(&quot;data.php&quot;, {name: &quot;hangge&quot;}, function(data){ alert(data); }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;请求数据&quot; onclick=&quot;btnClick()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 2，效果图点击“请求数据”按钮发起一个简单的get请求。可以看到虽然我们一开始只设置了name 这一个参数，但最终又自动添加了个 token（时间戳）参数。","link":"/2020/03/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%B9%8BjQuery%E8%87%AA%E5%8A%A8%E7%BB%99%E6%89%80%E6%9C%89Ajax%E8%AF%B7%E6%B1%82%E5%8A%A0%E4%B8%8A%E6%97%B6%E9%97%B4%E6%88%B3/"},{"title":"layui-tree如何实现懒加载以及动态加载子节点数据","text":"问题引入众所周知，layui.tree的树形控件，在渲染树节点时，需要后台准备好整个组织树的数据；如果组织树的数据量特别大，页面渲染特别慢。最近在狐小E智慧办公平台中，展示企业部门树时，就遇到这种问题；当时产品要求，部门树渲染要特别快，同时某部门下新增/删除了一个子部门时，要动态刷新，实时呈现；然而layui.tree的原始机制是，必须重新加载整个树的数据再渲染，这样就会导致展开的节点全收缩回去，而不是刚好展开到该父部门位置； 这样就有2个问题亟需优化 1）部门树数据量大、层级多时，全部渲染慢。 2）父部门添加子部门，当前父部门层级树无法做到局部更新视图； 为了解决这个问题，我们只好修改layui.tree源码，实现这个高大上功能；废话不多说，直接上干货： 狐小E智慧办公中台后台使用的layui版本是v2.5.x,其他版本的layui源码可能有所不同，这点需注意。 解决方案步骤1：源码修改首先，在layui前端框架找到实现树组件的模块源码tree.js，如图所示： 1：打开源码，在树的主渲染方法 r.render前，添加上用于加载child节点的方法r.children，代码如下： 1234 r.children = function (e, i, d) { var a = l.that[e]; return a.children(i, d)} 效果如下图： 2：找到b.prototype.tree方法，在此方法前，添加两个用于懒加载子节点的方法： 1234567891011121314151617181920212223242526272829303132333435363738b.prototype.children = function (n1, n2) { var e = this; e.setchildrendata(e.config.data, n1, n2);}, b.prototype.setchildrendata = function (n0, n1, n2) { var e = this; var c = i('#' + e.config.id); layui.each(n0, function (a, r) { var b = c.find('div[data-id=' + r.id + ']').hasClass(C); r.spread = b; if (e.config.accordion === !0) { //手风琴模式 r.spread = !1; var cs = c.find('div[data-id=' + n1 + ']').parents('.layui-tree-set'); cs.each(function () { if (r.id === i(this).attr('data-id')) { r.spread = !0; } }); } if (r.id === n1) { r.spread = !0; if(!r.children){ r.children=[]; } if (n2.length === 0) { delete r.children; }else{ //i.extend(!0, r.children, n2); r.children = n2; } e.reload(e.config.id, e.config.data); } if (r.children) { e.setchildrendata(r.children, n1, n2); //递归子节点 } });} 3：修改b.prototype.tree方法的代码，修改后代码如下【备注：//TODO 部分标识的为修改源码部分】 123456789101112131415161718192021222324252627282930313233b.prototype.tree = function (e, a) { var n = this, t = n.config, r = a || t.data; layui.each(r, function (a, r) { //TODO 此处调整源码 //var l = r.children &amp;&amp; r.children.length &gt; 0, var l = r.children, o = i('&lt;div class=\"layui-tree-pack\" ' + (r.spread ? 'style=\"display: block;\"' : \"\") + '\"&gt;&lt;/div&gt;'), //TODO 源码调整 //h = i(['&lt;div data-id=\"' + r.id + '\" class=\"layui-tree-set' + (r.spread ? \" layui-tree-spread\" : \"\") + (r.checked ? \" layui-tree-checkedFirst\" : \"\") + '\"&gt;', '&lt;div class=\"layui-tree-entry\"&gt;', '&lt;div class=\"layui-tree-main\"&gt;', function () { h = i(['&lt;div data-id=\"' + r.id + '\" data-parent-id=\"' + r.parentId + '\" class=\"layui-tree-set' + (r.spread ? \" layui-tree-spread\" : \"\") + (r.checked ? \" layui-tree-checkedFirst\" : \"\") + '\"&gt;', '&lt;div class=\"layui-tree-entry ' + (l ? \"taller\" : \"\") + '\" &gt;', '&lt;div class=\"layui-tree-main\"&gt;', function () { //TODO 源码调整 //return t.showLine ? l ? '&lt;span class=\"layui-tree-iconClick layui-tree-icon\"&gt;&lt;i class=\"layui-icon ' + (r.spread ? \"layui-icon-subtraction\" : \"layui-icon-addition\") + '\"&gt;&lt;/i&gt;&lt;/span&gt;' : '&lt;span class=\"layui-tree-iconClick\"&gt;&lt;i class=\"layui-icon layui-icon-file\"&gt;&lt;/i&gt;&lt;/span&gt;' : '&lt;span class=\"layui-tree-iconClick\"&gt;&lt;i class=\"layui-tree-iconArrow ' + (l ? \"\" : c) + '\"&gt;&lt;/i&gt;&lt;/span&gt;' return t.showLine ? l ? '&lt;span class=\"layui-tree-iconClick layui-tree-icon\"&gt;&lt;i class=\"layui-icon ' + (r.spread ? \"layui-icon-subtraction\" : \"layui-icon-addition\") + '\"&gt;&lt;/i&gt;&lt;/span&gt;' : '&lt;span class=\"layui-tree-iconClick layui-tree-icon\"&gt;&lt;i class=\"layui-icon layui-icon-file\"&gt;&lt;/i&gt;&lt;/span&gt;' : '&lt;span class=\"layui-tree-iconClick\"&gt;&lt;i class=\"layui-icon ' + ( r.spread ? \"layui-tree-active\" : \"layui-tree-iconArrow\") + (l ? \"\" : c)+' \"&gt;&lt;/i&gt;&lt;/span&gt;' }(), function () { return t.showCheckbox ? '&lt;input type=\"checkbox\" name=\"' + (r.field || \"layuiTreeCheck_\" + r.id) + '\" same=\"layuiTreeCheck\" lay-skin=\"primary\" ' + (r.disabled ? \"disabled\" : \"\") + ' value=\"' + r.id + '\"&gt;' : \"\" }(), function () { //TODO 修改源码 显示title //return t.isJump &amp;&amp; r.href ? '&lt;a href=\"' + r.href + '\" target=\"_blank\" class=\"' + y + '\"&gt;' + (r.title || r.label || t.text.defaultNodeName) + \"&lt;/a&gt;\" : '&lt;span class=\"' + y + (r.disabled ? \" \" + d : \"\") + '\"&gt;' + (r.title || r.label || t.text.defaultNodeName) + \"&lt;/span&gt;\" return t.isJump &amp;&amp; r.href ? '&lt;a title=\"' + (r.title || r.label || t.text.defaultNodeName) + '\" href=\"' + r.href + '\" target=\"_blank\" class=\"' + y + '\"&gt;' + (r.title || r.label || t.text.defaultNodeName) + \"&lt;/a&gt;\" : '&lt;span title=\"' + (r.title || r.label || t.text.defaultNodeName) + '\" class=\"' + y + (r.disabled ? \" \" + d : \"\") + '\" &gt;' + (r.title || r.label || t.text.defaultNodeName) + \"&lt;/span&gt;\" }(), \"&lt;/div&gt;\", function () { if (!t.edit) return \"\"; var e = { add: '&lt;i class=\"layui-icon layui-icon-add-1\" data-type=\"add\"&gt;&lt;/i&gt;', update: '&lt;i class=\"layui-icon layui-icon-edit\" data-type=\"update\"&gt;&lt;/i&gt;', del: '&lt;i class=\"layui-icon layui-icon-delete\" data-type=\"del\"&gt;&lt;/i&gt;' }, i = ['&lt;div class=\"layui-btn-group layui-tree-btnGroup\"&gt;']; return t.edit === !0 &amp;&amp; (t.edit = [\"update\", \"del\"]), \"object\" == typeof t.edit ? (layui.each(t.edit, function (a, n) { i.push(e[n] || \"\") }), i.join(\"\") + \"&lt;/div&gt;\") : void 0 }(), \"&lt;/div&gt;&lt;/div&gt;\"].join(\"\")); l &amp;&amp; (h.append(o), n.tree(o, r.children)), e.append(h), h.prev(\".\" + s)[0] &amp;&amp; h.prev().children(\".layui-tree-pack\").addClass(\"layui-tree-showLine\"), l || h.parent(\".layui-tree-pack\").addClass(\"layui-tree-lineExtend\"), n.spread(h, r), t.showCheckbox &amp;&amp; (r.checked &amp;&amp; n.checkids.push(r.id), n.checkClick(h, r)), t.edit &amp;&amp; n.operate(h, r) }) } 4：修改节点展开方法b.prototype.spread，修改后代码如下【备注：//TODO 部分标识的为修改源码部分】 1234567891011121314151617181920212223242526272829303132333435363738394041b.prototype.spread = function (e, a) { var n = this, t = n.config, r = e.children(\".\" + p), l = r.children(\".\" + f), c = r.find(\".\" + o), k = r.find(\".\" + y), m = t.onlyIconControl ? c : l, x = \"\"; m.on(\"click\", function (i) { var ax = e.children(\".\" + v),//TODO a冲突 改成ax //TODO 修改源码 //n = m.children(\".layui-icon\")[0] ? m.children(\".layui-icon\") : m.find(\".layui-tree-icon\").children(\".layui-icon\"); n = m.children(\".layui-icon\")[0] ? m.find(\".layui-tree-iconClick\").children(\".layui-icon\") : m.find(\".layui-tree-icon\").children(\".layui-icon\"); if (ax[0]) { //TODO a改为ax //TODO 展开节点 if (!e.hasClass(c) &amp;&amp; !e.hasClass(C)) { t.spread &amp;&amp; t.spread({ elem: e, state: a.children.length &gt; 0, data: a }) } //TODO 注释掉源码 /*if (e.hasClass(C)) e.removeClass(C), a.slideUp(200), n.removeClass(u).addClass(h); else if (e.addClass(C), a.slideDown(200), n.addClass(u).removeClass(h), t.accordion) { var r = e.siblings(\".\" + s); r.removeClass(C), r.children(\".\" + v).slideUp(200), r.find(\".layui-tree-icon\").children(\".layui-icon\").removeClass(u).addClass(h) }*/ //TODO 节点展开效果调整 添加Begin if (e.hasClass(C) &amp;&amp; !$(i.target).hasClass(\"layui-tree-txt\")) { e.removeClass(C), ax.slideUp(200) //修改源码，调整无实线状态时三角图标有动画 if (!t.showLine) { m.find('span .layui-icon').removeClass(aa).addClass(bb) } else { n.removeClass(u).addClass(h) } } else if (e.addClass(C), ax.slideDown(200), n.addClass(u).removeClass(h), t.accordion) { var r = e.siblings(\".\" + s); r.removeClass(C), r.children(\".\" + v).slideUp(200), r.find(\".layui-tree-icon\").children(\".layui-icon\").removeClass(u).addClass(h) } else if (!t.showLine) { m.find('span .layui-icon').removeClass(bb).addClass(aa) } //TODO 节点展开效果调整 添加End } else x = \"normal\" }) 5：b.prototype.spread 方法修改中，有两处样式添加 aa 、bb:如下所示 ​ 需要在tree.js中顶部样式变量处添加。 12345c = \"layui-hide\", d = \"layui-disabled\", s = \"layui-tree-set\", o = \"layui-tree-iconClick\", h = \"layui-icon-addition\", u = \"layui-icon-subtraction\", p = \"layui-tree-entry\", f = \"layui-tree-main\", y = \"layui-tree-txt\", v = \"layui-tree-pack\", C = \"layui-tree-spread\", k = \"layui-tree-setLineShort\", m = \"layui-tree-showLine\", x = \"layui-tree-lineExtend\" , aa = \"layui-tree-active\", bb = \"layui-tree-iconArrow\", //TODO 添加aa、bb两个样式 步骤2：方案落地解决问题1：异步加载子节点下面是狐小E智慧办公中台后台通讯录模块中，部门树渲染加载的业务逻辑，其核心概念就是通过父节点ID查询子节点数据，绑定tree组件的spread函数，捕捉节点的展开事件，用户点击树节点，根据当前节点ID查询下一级节点，如果children节点有数据，则调用tree的children函数动态地渲染子节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//获取部门树function LoadDeptTree() { $.ajax({ url: \"${ctx}/dept/tree/one-level?parentId=0\", dataType: \"json\", async: true, type: \"GET\", success: function (resp) { if (resp &amp;&amp; resp.msgcode == 0) { //无连接线风格 deptTree =tree.render({ elem: '#leftTreeArea' ,id:'leftTreeArea' , data: resp.data , showLine: false //是否开启连接线 , click: editDept , spread: function (obj) { if (!obj.state) { // 懒加载子节点，异步获取data数据 这里根据obj.data.id向后台请求当前节点数据 $.ajax({ url: \"${ctx}/dept/tree/one-level?parentId=\"+obj.data.id, dataType: \"json\", async: true, type: \"GET\", success: function (resp) { //当前节点展开，如果下一层有children，则调用树的children方法，动态渲染子节点 if (resp &amp;&amp; resp.msgcode == 0) { //第一个参数是树绑定的页面元素ID //第二个参数是当前展开节点的ID //第三个参数是当前节点子节点的数据（数据格式参照layui的tree组件数据格式） tree.children(deptTree.config.id, obj.data.id, resp.data); } } }); } } }); } else { alert(\"加载部门树失败\") } }, error:function(XMLHttpRequest, textStatus, error){ if (error.code == 19) { window.location.reload(); }else{ alert(\"加载部门树失败\"); } } });} 解决问题2：父部门添加子部门，局部动态更新视图1234567891011121314151617181920//重新渲染树节点function refreshTreeNode(treeNodeId,treeNodeName) { $.ajax({ url: \"${ctx}/dept/tree/one-level?parentId=\"+treeNodeId, dataType: \"json\", async: true, type: \"GET\", success: function (resp) { if (resp &amp;&amp; resp.msgcode == 0) { tree.children(deptTree.config.id, treeNodeId, resp.data); if (treeNodeName) { //修改节点名称 $(\"div[data-id='\"+treeNodeId+\"']\").find(\".layui-tree-txt\").eq(0).html(treeNodeName).attr(\"title\",treeNodeName); } //光标重新定位到当前节点 $(\"div[data-id='\"+treeNodeId+\"']\").find(\".layui-tree- entry\").eq(0).addClass(\"layui-table-click\"); } } });}","link":"/2020/06/11/%E6%8A%80%E6%9C%AF%E8%BD%AF%E6%96%87%EF%BC%9Alayui-tree%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E7%88%B6%E8%8A%82%E7%82%B9%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE/"}],"tags":[],"categories":[]}